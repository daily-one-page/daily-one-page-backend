# 오늘한장 프로젝트 구현 일정표

> **기간:** 2025.01.19 (일) ~ 2025.02.20 (목)  
> **총 33일 (5주)**  
> **방식:** 병렬형 (백엔드 기능 완성 → 해당 프론트 바로 연동)

---

## 전체 플로우 요약

```
[1주차] 설계 ──────────────────────────────────────────
        ERD → API 명세 → 프로젝트 셋업 → 프론트 환경 셋업

[2주차] 인증 ──────────────────────────────────────────
        회원가입/로그인 API → JWT 구현 → 로그인 화면

[3주차] 핵심 기능 ─────────────────────────────────────
        페이지 CRUD API → 달력 조회 API → 페이지/달력 화면

[4주차] AI 연동 + 캐싱 ────────────────────────────────
        OpenAI 연동 → Redis 캐싱 → 피드백 화면

[5주차] 배포 + 마무리 ─────────────────────────────────
        Docker → AWS 배포 → CI/CD → 최종 테스트 + 문서 정리
```

---

## 1주차: 설계 (1/19 ~ 1/25)

> **목표:** 코드 한 줄 치기 전에 설계 완료. 이후 작업의 기반 마련.

### 플로우
```
기획서 검토 → ERD 설계 → API 명세 → 백엔드 셋업 → 프론트 셋업
```

### 날짜별 목표

| 날짜 | 구분 | 할 일 | 산출물 |
|------|------|-------|--------|
| 1/19 (일) | 설계 | 기획서 최종 검토, 엔티티 목록 추출 | 엔티티 목록 정리 |
| 1/20 (월) | 설계 | ERD 설계 (dbdiagram.io) | ERD 이미지 + 코드 |
| 1/21 (화) | 설계 | API 명세서 작성 (전체 엔드포인트) | API 명세서 v1 |
| 1/22 (수) | 백엔드 | Spring Boot 프로젝트 생성 + 기본 설정 | 프로젝트 초기 구조 |
| 1/23 (목) | 백엔드 | MySQL 연결 + Entity 클래스 생성 | Entity 코드 |
| 1/24 (금) | 프론트 | Flutter 프로젝트 생성 + 기본 구조 | 프론트 초기 구조 |
| 1/25 (토) | 정리 | 1주차 회고 + 설계 문서 보완 | 회고록 |

### 선후관계
```
ERD 완성 → API 명세 가능 (테이블 구조 알아야 응답 필드 정의)
API 명세 완성 → Entity 생성 가능 (필드 확정)
백엔드 셋업 완료 → 프론트 셋업 (API Base URL 등 설정)
```

### 학습 포인트
- [ ] ERD 정규화 개념 정리
- [ ] REST API 설계 원칙 정리

---

## 2주차: 인증 (1/26 ~ 2/1)

> **목표:** 회원가입/로그인 + JWT 인증 완성. 로그인 화면까지 연동.

### 플로우
```
User 엔티티 → 회원가입 API → 로그인 API → JWT 발급 → 
JWT 필터 → 토큰 재발급 → [프론트] 로그인 화면 연동
```

### 날짜별 목표

| 날짜 | 구분 | 할 일 | 산출물 |
|------|------|-------|--------|
| 1/26 (일) | 백엔드 | User 엔티티 + Repository 생성 | User 관련 코드 |
| 1/27 (월) | 백엔드 | 회원가입 API (이메일 중복체크, BCrypt) | POST /auth/signup |
| 1/28 (화) | 백엔드 | 로그인 API + JWT 토큰 발급 | POST /auth/login |
| 1/29 (수) | 백엔드 | JWT 필터 + Spring Security 설정 | 인증 필터 코드 |
| 1/30 (목) | 백엔드 | 토큰 재발급 API + 예외 처리 | POST /auth/refresh |
| 1/31 (금) | 프론트 | 로그인/회원가입 화면 + API 연동 | 로그인 화면 |
| 2/1 (토) | 정리 | 2주차 회고 + 트러블슈팅 정리 | 회고록 + 기술 정리 |

### 선후관계
```
User 엔티티 → 회원가입 API (저장할 테이블 필요)
회원가입 → 로그인 (가입된 유저로 테스트)
로그인 → JWT 필터 (발급된 토큰 검증)
JWT 완성 → 프론트 연동 (API 호출 가능)
```

### 학습 포인트
- [ ] 세션 vs JWT 차이점 정리
- [ ] JWT 구조 (Header, Payload, Signature) 정리
- [ ] Spring Security 인증 흐름 정리
- [ ] BCrypt 단방향 암호화 정리

### 면접 대비 질문
```
Q: 왜 JWT를 선택했나요?
Q: Access Token과 Refresh Token을 나눈 이유는?
Q: Spring Security 인증 흐름을 설명해주세요.
```

---

## 3주차: 핵심 기능 (2/2 ~ 2/8)

> **목표:** 페이지 CRUD + 달력 조회 완성. 메인 화면까지 연동.

### 플로우
```
Page 엔티티 → 페이지 생성 API → 페이지 조회 API → 
페이지 수정/삭제 → 달력 조회 API → [프론트] 페이지 작성/달력 화면
```

### 날짜별 목표

| 날짜 | 구분 | 할 일 | 산출물 |
|------|------|-------|--------|
| 2/2 (일) | 백엔드 | Page 엔티티 + Repository 생성 | Page 관련 코드 |
| 2/3 (월) | 백엔드 | 페이지 생성 API (오늘 날짜 중복 체크) | POST /pages |
| 2/4 (화) | 백엔드 | 페이지 조회 API (날짜별, 권한 체크) | GET /pages/{date} |
| 2/5 (수) | 백엔드 | 페이지 수정/삭제 API | PUT, DELETE /pages/{id} |
| 2/6 (목) | 백엔드 | 달력 조회 API + 인덱스 설계 | GET /pages?year=&month= |
| 2/7 (금) | 프론트 | 페이지 작성 화면 + 달력 화면 연동 | 메인 화면들 |
| 2/8 (토) | 정리 | 3주차 회고 + N+1 문제 정리 | 회고록 + 기술 정리 |

### 선후관계
```
Page 엔티티 → CRUD API (테이블 필요)
생성 API → 조회 API (데이터 있어야 조회 테스트)
단건 조회 → 달력 조회 (단건 먼저, 목록은 그 다음)
API 완성 → 프론트 연동
```

### 학습 포인트
- [ ] JPA N+1 문제 + Fetch Join 해결
- [ ] 복합 인덱스 (user_id, date) 설계 이유
- [ ] @Transactional 동작 원리
- [ ] REST API 설계 원칙 5가지

### 면접 대비 질문
```
Q: N+1 문제가 뭐고, 어떻게 해결했나요?
Q: 인덱스를 왜 걸었고, 어떤 기준으로 설계했나요?
Q: RESTful하게 설계한다는 게 뭔가요?
```

---

## 4주차: AI 연동 + 캐싱 (2/9 ~ 2/15)

> **목표:** AI 피드백 생성 + Redis 캐싱 완성. 피드백 화면까지 연동.

### 플로우
```
OpenAI API 연동 → 피드백 생성 로직 → Redis 설정 → 
캐싱 적용 → 에러 핸들링 → [프론트] 피드백 화면
```

### 날짜별 목표

| 날짜 | 구분 | 할 일 | 산출물 |
|------|------|-------|--------|
| 2/9 (일) | 백엔드 | OpenAI API 연동 (RestTemplate/WebClient) | OpenAI 클라이언트 |
| 2/10 (월) | 백엔드 | 피드백 생성 로직 + 프롬프트 설계 | 피드백 서비스 |
| 2/11 (화) | 백엔드 | 피드백 API 완성 | GET /feedback/today |
| 2/12 (수) | 백엔드 | Redis 설정 + 캐싱 적용 (TTL 24h) | 캐싱 로직 |
| 2/13 (목) | 백엔드 | 에러 핸들링 (Timeout, Fallback) | 예외 처리 코드 |
| 2/14 (금) | 프론트 | 피드백 표시 화면 + 로딩/에러 처리 | 피드백 화면 |
| 2/15 (토) | 정리 | 4주차 회고 + 캐싱/비동기 정리 | 회고록 + 기술 정리 |

### 선후관계
```
OpenAI 연동 → 피드백 로직 (API 호출 가능해야 로직 작성)
피드백 로직 → 캐싱 (동작 확인 후 캐싱 붙이기)
캐싱 → 에러 핸들링 (정상 케이스 후 예외 케이스)
백엔드 완성 → 프론트 연동
```

### 학습 포인트
- [ ] 동기 vs 비동기 차이
- [ ] Redis 특징 + 캐시 전략
- [ ] TTL 설정 기준
- [ ] 외부 API 장애 대응 (Timeout, Retry, Fallback)

### 면접 대비 질문
```
Q: 왜 Redis를 썼나요?
Q: 캐시 TTL은 어떻게 정했나요?
Q: OpenAI API가 장애나면 어떻게 처리하나요?
```

---

## 5주차: 배포 + 마무리 (2/16 ~ 2/20)

> **목표:** Docker + AWS 배포 + CI/CD. 최종 테스트 + 문서 정리.

### 플로우
```
Dockerfile 작성 → 로컬 Docker 테스트 → AWS EC2 + RDS 설정 → 
배포 → CI/CD 구축 → 최종 테스트 → 문서 정리
```

### 날짜별 목표

| 날짜 | 구분 | 할 일 | 산출물 |
|------|------|-------|--------|
| 2/16 (일) | 배포 | Dockerfile 작성 + 로컬 테스트 | Dockerfile |
| 2/17 (월) | 배포 | AWS EC2 + RDS + Redis 설정 | 인프라 구성 |
| 2/18 (화) | 배포 | 백엔드 배포 + 환경변수 설정 | 배포 완료 |
| 2/19 (수) | 배포 | GitHub Actions CI/CD 구축 | CI/CD 파이프라인 |
| 2/20 (목) | 마무리 | 최종 테스트 + README + 문서 정리 | 완성된 프로젝트 |

### 선후관계
```
Dockerfile → 로컬 테스트 (이미지 빌드 확인)
로컬 테스트 → AWS 배포 (로컬에서 되면 서버로)
배포 → CI/CD (수동 배포 후 자동화)
CI/CD → 최종 테스트 + 문서
```

### 학습 포인트
- [ ] Docker 기본 개념 + Dockerfile 작성법
- [ ] AWS EC2, RDS 기본 설정
- [ ] 환경변수 관리 (.env, application.yml 분리)
- [ ] GitHub Actions 기본 문법

### 면접 대비 질문
```
Q: Docker를 왜 썼나요?
Q: CI/CD 파이프라인은 어떻게 구성했나요?
Q: 배포 과정에서 어려웠던 점은?
```

---

## 산출물 체크리스트

### 설계 문서
- [ ] ERD (dbdiagram.io 이미지 + 코드)
- [ ] API 명세서
- [ ] 프로젝트 구조도

### 코드
- [ ] 백엔드 (Spring Boot)
- [ ] 프론트엔드 (Flutter)
- [ ] Dockerfile
- [ ] GitHub Actions 워크플로우

### 학습 정리
- [ ] 기술 선택 이유 정리 (JWT, JPA, Redis 등)
- [ ] 트러블슈팅 로그
- [ ] 주차별 회고록

### 최종
- [ ] README.md (프로젝트 소개 + 기술 스택 + 실행 방법)
- [ ] 배포된 서비스 URL
- [ ] 포트폴리오용 정리 문서

---

## 버퍼/리스크 관리

### 예상 리스크
| 리스크 | 대응 |
|--------|------|
| JWT 구현 막힘 | 2주차 토요일 버퍼 활용 |
| OpenAI API 이슈 | 목업 응답으로 우선 개발, API는 나중에 연동 |
| AWS 배포 삽질 | 5주차 앞부분에 배치해서 여유 확보 |
| 프론트 시간 부족 | AI 적극 활용 + 최소 기능만 구현 |

### 버퍼 타임
- 매주 토요일: 해당 주차 보완
- 5주차 목요일: 최종 버퍼

---

## 주간 루틴

```
[월~목] 구현 집중 (백엔드 → 프론트 순서)
[금] 프론트 연동 + 해당 주 기술 정리
[토] 회고 + 문서화 + 밀린 작업 보완
[일] 다음 주 준비 + 학습
```

---
